
typedef struct tObj{                  //Objektmall
	int height;
	int width;
	int posx, posy;
	int velx, vely;
	int accx, accy;
	char* sprite[MAX_POINTS];
	void (*draw) (struct tObj *);
	void (*jump) (struct tObj *);
}OBJECT, *POBJECT;

static OBJECT Pedro = 
{
	32, 20,				//height, width
	0,32,				//initial startposition
	0,0,				//Hastighet
	0,0,				//Acceleration
	pedro_still,		//Sprite
	draw,
	jump
};

#define MAX_VELX 4
#define ACCX 1

void move(POBJECT Pedro){								//Kollar knapptryck och uppdaterar alla Pedros v채rden
	if(isRightKey() && !isLeftKey()){     //Kr채ver importerad keyb
		if(Pedro->velx < MAX_VELX){
			Pedro->accx = ACCX;
		}
		else{
			Pedro->accx = 0;
		}
		Pedro->velx += Pedro->accx;
	}
	else if(!isRightKey() && isLeftKey())
	{
		if(Pedro->velx > -MAX_VELX){
			Pedro->accx = -ACCX;
		}
		else{
			Pedro->accx = 0;
		}
		Pedro->velx += Pedro->accx;
	}
	else
	{
		Pedro->accx = 0;
		if(Pedro->velx > 0){
			Pedro->velx -= ACCX;
		}
		if(Pedro->velx < 0){
			Pedro->velx += ACCX;
		}
	}
	Pedro->posx += Pedro->velx;
}

void draw(POBJECT object){		//Ritar ut pedro enligt hans position och utseende. Dessa st책r fria att 채ndras i andra metoder
	 unsigned char i, j;
	 unsigned char* man = object->sprite;
        for(j = 0; j < (object->height)/8; j++) {
            graphic_write_command(LCD_SET_PAGE | (((63-object->posy-object->height)/8)+j), B_CS1);
            graphic_write_command(LCD_SET_ADD | object->posx, B_CS1);
            for(i = 0; i < object->width; i++) {
				unsigned char byte = *(man+(j*object->width)+i);
                graphic_write_data(byte, B_CS1);
            }
        }
}

int objtouchesborder(POBJECT o){
    if((o->posx < 1) || (o->posx + o->width) > 128 ){
        return 1;
    }
    else if((o->posy < 1) || (o->posy + o->height) > 64){
        return 2;
    }
    return 0;
}
